{"version":3,"sources":["webpack://bpd-event-bus/webpack/universalModuleDefinition","webpack://bpd-event-bus/webpack/bootstrap","webpack://bpd-event-bus/./src/core/functions.ts","webpack://bpd-event-bus/./src/core/executors.ts","webpack://bpd-event-bus/./src/core/collection.ts","webpack://bpd-event-bus/./src/core/logger.ts","webpack://bpd-event-bus/./src/core/statics.ts","webpack://bpd-event-bus/./src/bus/handlers.ts","webpack://bpd-event-bus/./src/bus/performers.ts","webpack://bpd-event-bus/./src/core/errors.ts","webpack://bpd-event-bus/./src/bus/engine.ts","webpack://bpd-event-bus/./src/bus/statics.ts","webpack://bpd-event-bus/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","is","val","typecheck","length","Array","isArray","isEmpty","are","attributes","counter","idx","getContextArgumentId","ctx","eventId","callback","args","apply","this","has","push","index","indexOf","splice","includes","logger","message","log","type","Date","toLocaleString","performer","logCallback","queue","isBusy","event","events","id","error","createKey","add","queueItem","first","perform","e","remove","next","BasicEventEmitHandler","super","eventName","nextId","count","JSON","stringify","join","emitId","handleId","executor","data","target","idMatches","execute","promises","Promise","all","ErrorBase","Error","setPrototypeOf","ArgumentError","emitHandler","context","prepareEventId","info","ev","isAttached","handle","getRandomEventId","setup","sort","second","priority","forEach","item","initBusInstance","mapEvents","eventsDef","handling","policy","on","detach","detachAll","emit","isSubscribing","reduce","result","current","getPerformer","handler","BPD_EVENT_BUS_VERSION","$bpdEventBusVersion","$bpdEvenBusFactory"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bpd-event-bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bpd-event-bus\"] = factory();\n\telse\n\t\troot[\"bpd-event-bus\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { ContextArgument } from \"./interfaces\";\r\n\r\n/**\r\n * Checks if value is defined an is not null\r\n * Additionally with type check it can check value if it is not empty string or collection or object\r\n * \r\n * @param val - value\r\n * @param typecheck - default true - additional check whether value is not empty (string, collection, object)\r\n * @returns whether value passed all conditions\r\n */\r\nexport function is(val: any, typecheck: boolean = true): boolean {\r\n    if (typeof val !== 'undefined' && val !== null) {\r\n        if (!typecheck) {\r\n            return true;\r\n        } else {\r\n            return !isEmpty(val)\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if value is empty string, array or object\r\n *\r\n *\r\n * @param val - value\r\n * @returns whether value passed all conditions\r\n */\r\nexport function isEmpty(val: any): boolean {\r\n    if (typeof val === \"string\") {\r\n        return val.length === 0\r\n    }\r\n    if (typeof val === \"boolean\") {\r\n        return val;\r\n    }\r\n    else if (Array.isArray(val)) {\r\n        return val.length === 0\r\n    }\r\n    return false\r\n}\r\n\r\n/**\r\n * Verifies whether attributes exist and have some values\r\n * @param attributes attributes list\r\n */\r\nexport function are(...attributes: any[]): boolean {\r\n    if (!is(attributes)) {\r\n        return false\r\n    }\r\n    let c = attributes.length;\r\n    for (let i = 0; i < c; i++) {\r\n        if (!is(attributes[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nexport function* counter() {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function getContextArgumentId(ctx?: ContextArgument): string | null {\r\n    if (!ctx) {\r\n        return null;\r\n    } else if (typeof ctx === 'string') {\r\n        return ctx;\r\n    } else {\r\n        return ctx.eventId;\r\n    }\r\n}","import { is } from \"./functions\"\r\nimport { IBpdCallbackExecutor } from \"./interfaces\"\r\n\r\nexport class BpdCallbackExecutor implements IBpdCallbackExecutor {\r\n    async execute(callback: any, ctx: any, args: any[]): Promise<void> {\r\n        args = args ?? []\r\n        if (is(ctx) && typeof ctx !== 'string') {\r\n            callback.apply(ctx, args)\r\n        } else {\r\n            callback(...args)\r\n        }\r\n        return\r\n    }\r\n}","import { IBpdCollection, BpdCollectionPair } from \"./interfaces\";\r\nimport { is } from \"./functions\";\r\n\r\nexport class BpdEventsCollection<T> implements IBpdCollection<T> {\r\n    #keys: string[];\r\n    #values: T[];\r\n    constructor() {\r\n        this.#keys = []\r\n        this.#values = []\r\n    }\r\n\r\n\r\n    add(key: string, value: T): void {\r\n        if (is(key) && !this.has(key)) {\r\n            this.#keys.push(key);\r\n            this.#values.push(value);\r\n        }\r\n    }\r\n\r\n    remove(key: string): void {\r\n        if (is(key) && this.has(key)) {\r\n            let index = this.indexOf(key);\r\n            if (index > -1) {\r\n                this.#keys.splice(index, 1);\r\n                this.#values.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    has(key: string): boolean {\r\n        return this.#keys.includes(key);\r\n    }\r\n\r\n    get(index: number): BpdCollectionPair<T> | null {\r\n        if (index > -1 && index < this.length()) {\r\n            return {\r\n                key: this.#keys[index],\r\n                value: this.#values[index]\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    first(): BpdCollectionPair<T> | null {\r\n        return this.get(0);\r\n    }\r\n\r\n    length(): number {\r\n        return this.#keys.length;\r\n    }\r\n\r\n    indexOf(key: string): number {\r\n        return this.#keys.indexOf(key);\r\n    }\r\n\r\n}","import { BpdEventLoggerCallback } from \"./interfaces\";\r\nimport { ERROR, INFO } from \"./statics\";\r\n\r\nexport interface IBpdEventBusLogging {\r\n    error(ctx: string, message?: string): void;\r\n    info(ctx: string, message?: string): void;\r\n    set(logger: BpdEventLoggerCallback): void;\r\n    get(): BpdEventLoggerCallback | undefined;\r\n}\r\n\r\nexport class BpdEventBusLogging implements IBpdEventBusLogging {\r\n    #logger: BpdEventLoggerCallback | undefined;\r\n\r\n    constructor(logger?: BpdEventLoggerCallback) {\r\n        this.#logger = logger;\r\n    }\r\n\r\n    set(logger?: BpdEventLoggerCallback) {\r\n        this.#logger = logger;\r\n    }\r\n\r\n    get() {\r\n        return this.#logger;\r\n    }\r\n\r\n    error(ctx: string, message?: string) {\r\n        this.log(ERROR, ctx, message);\r\n    }\r\n\r\n    info(ctx: string, message?: string) {\r\n        this.log(INFO, ctx, message);\r\n    }\r\n\r\n    private log(type: string, ctx: string, message?: string) {\r\n        if (this.#logger) {\r\n            this.#logger(type, ctx, new Date().toLocaleString(), message);\r\n        }\r\n    }\r\n}","export const ERROR = \"ERROR\";\r\nexport const INFO = \"INFO\";","import { BpdEventReceiver, IBpdEventEmitHandler, IBpdCallbackExecutor, BpdEventLoggerCallback, IBpdCollection, IBpdHandlerPerformer, EmitHandlerData } from \"../core/interfaces\";\r\nimport { is, counter } from \"../core/functions\";\r\nimport { INFO, ERROR } from \"../core/statics\";\r\nimport { BpdEventsCollection } from \"../core/collection\";\r\nimport { BpdEventBusLogging, IBpdEventBusLogging } from \"../core/logger\";\r\n\r\n\r\n\r\nabstract class EmitHandlerBase {\r\n    isBusy: boolean;\r\n    queue: IBpdCollection<EmitHandlerData>;\r\n    #logger: IBpdEventBusLogging;\r\n    #counter: Generator<number, void, unknown>;\r\n    #performer: IBpdHandlerPerformer;\r\n    constructor(type: string, performer: IBpdHandlerPerformer, logCallback?: BpdEventLoggerCallback) {\r\n        this.queue = new BpdEventsCollection();\r\n        this.#performer = performer;\r\n        this.isBusy = false;\r\n        this.#logger = new BpdEventBusLogging(logCallback);\r\n        this.#counter = counter();\r\n    }\r\n\r\n    async handle(event: string, events: BpdEventReceiver, id: string | null, args: any[]): Promise<boolean> {\r\n        if (!is(events)) {\r\n            this.#logger.error(\"handle\", \"No events provided\")\r\n            return false;\r\n        }\r\n        let key = this.createKey(event, args);\r\n        this.queue.add(key, {\r\n            events: events,\r\n            id: id,\r\n            args: args\r\n        })\r\n\r\n        if (!this.isBusy) {\r\n            this.isBusy = true;\r\n            let queueItem = null;\r\n            while (this.queue.length() > 0) {\r\n                queueItem = this.queue.first();\r\n                if (!queueItem) {\r\n                    break;\r\n                }\r\n                try {\r\n                    if (queueItem.value)\r\n                        await this.#performer.perform(queueItem.value);\r\n                } catch (e) {\r\n                    this.#logger.error(\"perform\", e.message)\r\n                } finally {\r\n                    this.queue.remove(queueItem.key);\r\n                }\r\n\r\n            }\r\n            this.isBusy = false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    protected nextId(): string {\r\n        return \"#\" + this.#counter.next().value;\r\n    }\r\n\r\n    protected abstract createKey(event: string, args: any[]): string;\r\n\r\n}\r\n\r\nexport class BasicEventEmitHandler extends EmitHandlerBase implements IBpdEventEmitHandler {\r\n\r\n    constructor(performer: IBpdHandlerPerformer, logCallback?: BpdEventLoggerCallback) {\r\n        super(\"BasicEventEmitHandler\", performer, logCallback);\r\n    }\r\n\r\n    createKey(eventName: string, args: any[]): string {\r\n        return this.nextId();\r\n    }\r\n}\r\n\r\n// Extended handler\r\n\r\nexport class ExtendedEventEmitHandler extends EmitHandlerBase implements IBpdEventEmitHandler {\r\n    constructor(performer: IBpdHandlerPerformer, logCallback?: BpdEventLoggerCallback) {\r\n        super(\"ExtendedEventEmitHandler\", performer, logCallback);\r\n    }\r\n\r\n    createKey(eventName: string, args: any[]): string {\r\n        let count = is(args) ? args.length : 0;\r\n        let id = null;\r\n        if (count > 0) {\r\n            if (args.length === 1) {\r\n                let val = args[0];\r\n                if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {\r\n                    id = \"s:\" + val;\r\n                } else if (val.id) {\r\n                    id = \"ID:\" + val.id;\r\n                } else if (val.key) {\r\n                    id = \"KEY:\" + val.key;\r\n                }\r\n            } else {\r\n\r\n            }\r\n            return [eventName, count, id === null ? JSON.stringify(args) : id].join(\"-\");\r\n        }\r\n\r\n        return [eventName, count].join(\"-\");\r\n    }\r\n}\r\n\r\nexport class BpdEventEmitHandlerFactory {\r\n    static get(name: string, performer: IBpdHandlerPerformer, logCallback?: BpdEventLoggerCallback): IBpdEventEmitHandler {\r\n        switch (name) {\r\n            case \"extended\":\r\n                return new ExtendedEventEmitHandler(performer, logCallback);\r\n            default:\r\n                return new BasicEventEmitHandler(performer, logCallback);\r\n        }\r\n    }\r\n}","import { BpdCallbackExecutor } from \"../core/executors\";\r\nimport { is, getContextArgumentId } from \"../core/functions\";\r\nimport { IBpdHandlerPerformer, IBpdCallbackExecutor, EmitHandlerData } from \"../core/interfaces\";\r\n\r\nexport class BpdHandlePerformerBase {\r\n    protected idMatches(emitId: string | null, handleId: string | null) {\r\n        return !is(emitId) || (is(emitId) && emitId == handleId);\r\n    }\r\n}\r\n\r\nexport class BpdBasicHandlePerformer extends BpdHandlePerformerBase implements IBpdHandlerPerformer {\r\n    #executor: IBpdCallbackExecutor;\r\n    constructor(executor: IBpdCallbackExecutor) {\r\n        super();\r\n        this.#executor = executor;\r\n    }\r\n\r\n    async perform(data: EmitHandlerData): Promise<boolean> {\r\n        let event = null;\r\n        let handleId = null;\r\n        for (let id in data.events) {\r\n            event = data.events[id]\r\n            handleId = event.target ? getContextArgumentId(event.target) : null;\r\n            if (this.idMatches(data.id, handleId))\r\n                await this.#executor.execute(event.callback, event.ctx, data.args)\r\n\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\nexport class BpdAsyncHandlePerformer extends BpdHandlePerformerBase implements IBpdHandlerPerformer {\r\n    #executor: IBpdCallbackExecutor;\r\n    constructor(executor: IBpdCallbackExecutor) {\r\n        super();\r\n        this.#executor = executor;\r\n    }\r\n\r\n    async perform(data: EmitHandlerData): Promise<boolean> {\r\n        let promises: Promise<void>[] = []\r\n        let event = null;\r\n        let handleId = null;\r\n        for (let id in data.events) {\r\n            event = data.events[id]\r\n            handleId = getContextArgumentId(event.target);\r\n            if (this.idMatches(data.id, handleId))\r\n                promises.push(this.#executor.execute(event.callback, event.ctx, data.args))\r\n        }\r\n        await Promise.all(promises)\r\n        return true;\r\n    }\r\n}\r\n\r\nexport function getPerformer(executor: BpdCallbackExecutor, policy?: string) {\r\n    return policy === \"tasked\" ? new BpdAsyncHandlePerformer(executor) : new BpdBasicHandlePerformer(executor);\r\n}","export class ErrorBase extends Error {\r\n    constructor(name: string, message?: string,) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport class ArgumentError extends ErrorBase {\r\n    constructor(message?: string) {\r\n        super(\"ArgumentError\", message);\r\n    }\r\n}","import { are, is, counter, getContextArgumentId } from \"../core/functions\";\r\nimport { IBpdEventBus, BpdEventReceiver, IBpdEventEmitHandler, BpdEventLoggerCallback, ContextArgument, BpdEventBusSetup, BpdEventDetails, IBpdEventBusInstanceSetup, IBpdLoggable, IBpdBusMapping } from \"../core/interfaces\";\r\nimport { BpdCallbackExecutor } from \"../core/executors\";\r\nimport { BpdEventEmitHandlerFactory } from \"../bus/handlers\";\r\nimport { getPerformer } from \"../bus/performers\";\r\nimport { ArgumentError } from \"../core/errors\";\r\nimport { BpdEventBusLogging, IBpdEventBusLogging } from \"../core/logger\";\r\nimport { getDefaultBusSetup } from \"./statics\";\r\nexport { BpdEventContext as CuiEventContext } from \"../core/interfaces\";\r\n\r\nexport class BpdEventBusFactory {\r\n    static create(setup?: BpdEventBusSetup): IBpdEventBus {\r\n        if (!setup || !setup.queue || setup.queue.length === 0) {\r\n            return initBusInstance(getDefaultBusSetup());\r\n        }\r\n        let bus = new BpdEventBusFarm(setup.queue, setup.logger);\r\n        return bus;\r\n    }\r\n}\r\n\r\nexport class BpdEventBus implements IBpdEventBus {\r\n    #events: { [event: string]: BpdEventReceiver }\r\n    #eventHandler: IBpdEventEmitHandler;\r\n    #logger: IBpdEventBusLogging;\r\n    #counter: Generator<number, void, unknown>;\r\n    #name: string;\r\n    constructor(emitHandler: IBpdEventEmitHandler, name: string, logCallback?: BpdEventLoggerCallback) {\r\n        this.#events = {};\r\n        this.#eventHandler = emitHandler;\r\n        this.#counter = counter();\r\n        this.#name = name ?? \"EVENT_BUS\";\r\n        this.#logger = new BpdEventBusLogging(logCallback);\r\n    }\r\n\r\n    /**\r\n     * Attaches event to event bus\r\n     * \r\n     * @param {string} name - Event name\r\n     * @param {any} callback - callback function\r\n     * @param {ContextArgument} ctx - callback context with id\r\n     * @param {ContextArgument} target - optional - cui element which event shall be attached to\r\n     */\r\n    on(name: string, callback: any, context?: BpdEventDetails): string {\r\n        if (!are(name, callback)) {\r\n            this.#logger.error('on', \"Missing argument\")\r\n        }\r\n        // When context is not provided (e.g. anonymous function) then generate random\r\n        let id = this.prepareEventId(getContextArgumentId(context?.ctx));\r\n\r\n        this.#logger.info(\"on\", `Attaching new event: [${name}] for: [${id}]`)\r\n        if (!this.#events[name]) {\r\n            this.#events[name] = {}\r\n        }\r\n\r\n        this.#events[name][id] = { ctx: context?.ctx, callback: callback, target: context?.target }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n    * Detaches specific event from event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    detach(name: string, ctx: ContextArgument): void {\r\n        if (!is(name)) {\r\n            this.#logger.error(\"detach\", \"Missing argument\")\r\n        }\r\n        let ev = this.#events[name]\r\n        let id = getContextArgumentId(ctx);\r\n        this.#logger.info(\"detach\", `Detaching item: [${id}] from [${name}]`);\r\n        if (is(id) && this.isAttached(ev, id)) {\r\n            // @ts-ignore already checked \r\n            delete ev[id];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Detaches all callbacks from event\r\n    *\r\n    * @param {string} name - Event name\r\n    */\r\n    detachAll(name: string): void {\r\n        if (is(name) && this.#events[name]) {\r\n            delete this.#events[name]\r\n        } else {\r\n            this.#logger.error(\"detachAll\", \"Event name is missing or incorrect\")\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Emits event call to event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} cuid - id of component which emits the event\r\n    * @param {any[]} args  - event arguments\r\n    */\r\n    async emit(event: string, target: ContextArgument, ...args: any[]): Promise<boolean> {\r\n        if (!is(event)) {\r\n            throw new ArgumentError(\"Event name is incorrect\");\r\n        }\r\n        let id = getContextArgumentId(target);\r\n        this.#logger.info(\"emit\", `Emit: [${event}], id: [${id}]`);\r\n        await this.#eventHandler.handle(event, this.#events[event], id, args)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Checks whether given context is already attached to specific event\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    isSubscribing(name: string, ctx: ContextArgument) {\r\n        let ev = this.#events[name]\r\n        return this.isAttached(ev, getContextArgumentId(ctx));\r\n    }\r\n\r\n    private isAttached(ev: BpdEventReceiver, id: string | null): boolean {\r\n        //@ts-ignore id already checked\r\n        return is(ev) && is(id) && is(ev[id]);\r\n    }\r\n\r\n    private prepareEventId(ctx: string | null): string {\r\n        //@ts-ignore id already checked\r\n        return is(ctx) ? ctx : this.getRandomEventId();\r\n    }\r\n\r\n    private getRandomEventId(): string {\r\n        return this.#name + \"_\" + this.#counter.next().value;\r\n    }\r\n}\r\n\r\nexport class BpdEventBusFarm implements IBpdEventBus {\r\n    #events: { [event: string]: number };\r\n    #buses: IBpdEventBus[];\r\n    #last: number;\r\n    #logger: IBpdEventBusLogging;\r\n    #ctx: string;\r\n    constructor(setup: IBpdEventBusInstanceSetup[], logCallback?: BpdEventLoggerCallback) {\r\n        this.#ctx = \"EXT\";\r\n        this.#logger = new BpdEventBusLogging(logCallback);\r\n        this.#buses = [];\r\n        this.#events = {};\r\n        this.#last = 0;\r\n        if (is(setup)) {\r\n            this.#logger.info(this.#ctx, \"Initiating buses\")\r\n            let sorted = setup.length === 1 ? setup : setup.sort((first, second) => {\r\n                return first.priority - second.priority\r\n            })\r\n            sorted.forEach((item, index) => {\r\n                this.#buses.push(initBusInstance(item, logCallback))\r\n                this.#events = {\r\n                    ...this.#events,\r\n                    ...this.mapEvents(item.eventsDef, index),\r\n                }\r\n                this.#logger.info(this.#ctx, `Bus ${item.name} has been initialized with number: ${index}`)\r\n            })\r\n\r\n            this.#buses.push(initBusInstance(getDefaultBusSetup(), logCallback))\r\n            this.#last = this.#buses.length - 1;\r\n            this.#logger.info(this.#ctx, `Bus initialization finished`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches event to event bus\r\n     * \r\n     * @param {string} name - Event name\r\n     * @param {any} callback - callback function\r\n     * @param {BpdEventDetails} ctx - callback context with id\r\n     */\r\n    on(name: string, callback: any, ctx?: BpdEventDetails): string | null {\r\n\r\n        if (!are(name, callback)) {\r\n            throw new ArgumentError(\"Missing argument\")\r\n        }\r\n        return this.get(name).on(name, callback, ctx);\r\n    }\r\n\r\n    /**\r\n    * Detaches specific event from event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    detach(name: string, ctx: ContextArgument): void {\r\n        if (!are(name, ctx)) {\r\n            throw new ArgumentError(\"Missing argument\")\r\n        }\r\n        this.get(name).detach(name, ctx);\r\n    }\r\n\r\n    /**\r\n    * Detaches all callbacks from event\r\n    *\r\n    * @param {string} name - Event name\r\n    */\r\n    detachAll(name: string): void {\r\n        this.get(name).detachAll(name);\r\n    }\r\n\r\n    /**\r\n    * Emits event call to event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - id of component which emits the event\r\n    * @param {any[]} args  - event arguments\r\n    */\r\n    async emit(event: string, context: ContextArgument, ...args: any[]): Promise<boolean> {\r\n        if (!is(event)) {\r\n            throw new ArgumentError(\"Event name is incorrect\");\r\n        }\r\n        return this.get(event).emit(event, context, ...args);\r\n    }\r\n\r\n    /**\r\n    * Checks whether given context is already attached to specific event\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    isSubscribing(name: string, ctx?: ContextArgument) {\r\n        return this.get(name).isSubscribing(name, ctx);\r\n    }\r\n\r\n    /**\r\n     * Creates mapping object from events array\r\n     * @param events events array\r\n     * @param index queue number\r\n     */\r\n    private mapEvents(events: string[], index: number): IBpdBusMapping {\r\n        return events.reduce((result: IBpdBusMapping, current: string) => {\r\n            if (!result[current]) {\r\n                return {\r\n                    ...result,\r\n                    [current]: index\r\n                }\r\n            }\r\n            return result;\r\n        }, {})\r\n    }\r\n\r\n    /**\r\n     * Retrives porper event bus based on event name\r\n     * @param event \r\n     */\r\n    private get(event: string): IBpdEventBus {\r\n        let idx = this.#events[event];\r\n        return this.#buses[idx ?? this.#last];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Function that initiates single bus insatnce \r\n * @param setup \r\n * @param logger \r\n */\r\nfunction initBusInstance(setup: IBpdEventBusInstanceSetup, logCallback?: BpdEventLoggerCallback): IBpdEventBus {\r\n    if (!are(setup.name, setup.handling)) {\r\n        throw new ArgumentError(\"Bus name or handler name is incorrect\");\r\n    }\r\n    let executor = new BpdCallbackExecutor();\r\n    let performer = getPerformer(executor, setup.policy);\r\n    let handler = BpdEventEmitHandlerFactory.get(setup.handling ?? \"\", performer, logCallback);\r\n    const bus = new BpdEventBus(handler, setup.name, logCallback);\r\n    return bus;\r\n}","import { IBpdEventBusInstanceSetup } from \"../core/interfaces\";\r\n\r\nexport function getDefaultBusSetup(): IBpdEventBusInstanceSetup {\r\n    return {\r\n        name: \"Default\",\r\n        handling: \"basic\",\r\n        policy: \"tasked\",\r\n        eventsDef: [],\r\n        priority: 99\r\n    }\r\n} ","import { BpdEventBusFactory } from \"./bus/engine\";\r\n\r\nexport const BPD_EVENT_BUS_VERSION = \"0.1.3\";\r\n\r\ndeclare global {\r\n    interface Window {\r\n        $bpdEventBusVersion: string;\r\n        $bpdEvenBusFactory: BpdEventBusFactory;\r\n    }\r\n}\r\n\r\nwindow.$bpdEventBusVersion = BPD_EVENT_BUS_VERSION;\r\nwindow.$bpdEvenBusFactory = BpdEventBusFactory;"],"sourceRoot":""}