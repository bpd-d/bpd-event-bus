{"version":3,"sources":["webpack://cui-light/webpack/universalModuleDefinition","webpack://cui-light/webpack/bootstrap","webpack://cui-light/./src/functions.ts","webpack://cui-light/./src/executors.ts","webpack://cui-light/./src/collection.ts","webpack://cui-light/./src/handlers.ts","webpack://cui-light/./src/statics.ts","webpack://cui-light/./src/performers.ts","webpack://cui-light/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","is","val","typecheck","length","Array","isArray","isEmpty","counter","idx","getContextArgumentId","ctx","id","callback","args","apply","this","has","push","index","indexOf","splice","includes","type","performer","logger","queue","isBusy","event","events","logError","createKey","add","queueItem","first","perform","e","message","remove","context","log","next","Date","toLocaleString","SimpleEventEmitHandler","super","eventName","nextId","emitId","handleId","executor","data","promises","target","idMatches","execute","Promise","all","setup","bus","setLogger","emitHandler","attributes","are","prepareEventId","logInfo","ev","isAttached","handle","getRandomEventId"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,YAAa,GAAIH,GACE,iBAAZC,QACdA,QAAQ,aAAeD,IAEvBD,EAAK,aAAeC,IARtB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+BCxE9C,SAASC,EAAGC,EAAUC,GAAqB,GAC9C,OAAI,MAAOD,KACFC,IAgBN,SAAiBD,GACpB,GAAmB,iBAARA,EACP,OAAsB,IAAfA,EAAIE,OAEf,GAAmB,kBAARF,EACP,OAAOA,EAEN,GAAIG,MAAMC,QAAQJ,GACnB,OAAsB,IAAfA,EAAIE,OAEf,OAAO,EAvBSG,CAAQL,IA4CrB,SAAUM,IACb,IAAIC,EAAM,EACV,OAAa,SACSA,MACLA,EAAM,OACfA,EAAM,IAMX,SAASC,EAAqBC,GACjC,OAAKA,EAEqB,iBAARA,EACPA,EAEAA,EAAIC,GAJJ,K,gZCpER,MAAM,EACH,QAAQC,EAAeF,EAAUG,G,yCACnCA,EAAOA,UAAQ,GACXb,EAAGU,GACHE,EAASE,MAAMJ,EAAKG,GAEpBD,KAAYC,O,sPCPjB,MAAM,EAGT,cAFA,mBACA,mBAEI,EAAAE,KAAI,EAAS,IACb,EAAAA,KAAI,EAAW,IAInB,IAAIxB,EAAaN,GACTe,EAAGT,KAASwB,KAAKC,IAAIzB,KACrB,EAAAwB,KAAA,GAAWE,KAAK1B,GAChB,EAAAwB,KAAA,GAAaE,KAAKhC,IAI1B,OAAOM,GACH,GAAIS,EAAGT,IAAQwB,KAAKC,IAAIzB,GAAM,CAC1B,IAAI2B,EAAQH,KAAKI,QAAQ5B,GACrB2B,GAAS,IACT,EAAAH,KAAA,GAAWK,OAAOF,EAAO,GACzB,EAAAH,KAAA,GAAaK,OAAOF,EAAO,KAKvC,IAAI3B,GACA,OAAO,EAAAwB,KAAA,GAAWM,SAAS9B,GAG/B,IAAI2B,GACA,OAAIA,GAAS,GAAKA,EAAQH,KAAKZ,SACpB,CACHZ,IAAK,EAAAwB,KAAA,GAAWG,GAChBjC,MAAO,EAAA8B,KAAA,GAAaG,IAGrB,KAGX,QACI,OAAOH,KAAKlC,IAAI,GAGpB,SACI,OAAO,EAAAkC,KAAA,GAAWZ,OAGtB,QAAQZ,GACJ,OAAO,EAAAwB,KAAA,GAAWI,QAAQ5B,I,4jBC7ClC,MAAe,EAOX,YAAY+B,EAAcC,EAAiCC,GAJ3D,mBACA,mBACA,mBACA,mBAEIT,KAAKU,MAAQ,IAAI,EACjB,EAAAV,KAAI,EAAcQ,GAClBR,KAAKW,QAAS,EACd,EAAAX,KAAI,EAAWS,GACf,EAAAT,KAAI,EAASO,GACb,EAAAP,KAAI,EAAYR,KAGd,OAAOoB,EAAeC,EAA0BjB,EAAYE,G,yCAC9D,IAAKb,EAAG4B,GAEJ,YADAb,KAAKc,SAAS,SAAU,sBAG5B,IAAItC,EAAMwB,KAAKe,UAAUH,EAAOd,GAOhC,GANAE,KAAKU,MAAMM,IAAIxC,EAAK,CAChBqC,OAAQA,EACRjB,GAAIA,EACJE,KAAMA,KAGLE,KAAKW,OAAQ,CACdX,KAAKW,QAAS,EACd,IAAIM,EAAY,KAChB,KAAOjB,KAAKU,MAAMtB,SAAW,GAAG,CAC5B6B,EAAYjB,KAAKU,MAAMQ,QACvB,UACU,EAAAlB,KAAA,GAAgBmB,QAAQF,EAAU/C,OAC1C,MAAOkD,GACLpB,KAAKc,SAAS,UAAWM,EAAEC,S,QAE3BrB,KAAKU,MAAMY,OAAOL,EAAUzC,MAIpCwB,KAAKW,QAAS,EAElB,OAAO,KAID,SAASY,EAAiBF,GAChCrB,KAAKwB,ICvDO,ODuDGD,EAASF,GAGlB,SAASE,EAAiBF,GAChCrB,KAAKwB,IC5DQ,QD4DGD,EAASF,GAGnB,SACN,MAAO,IAAM,EAAArB,KAAA,GAAcyB,OAAOvD,MAG9B,IAAIqC,EAAcgB,EAAiBF,GACnCpC,EAAG,EAAAe,KAAA,KACH,EAAAA,KAAA,QAAAA,KAAaO,EAAM,IAAI,EAAAP,KAAA,QAAgBuB,MAAY,IAAIG,MAAOC,iBAAkBN,I,wDAQrF,MAAMO,UAA+B,EAExC,YAAYpB,GACRqB,MAAM,yBAA0BrB,GAGpC,UAAUsB,EAAmBhC,GACzB,OAAOE,KAAK+B,U,0hBEjFb,MAAM,EACC,UAAUC,EAAgBC,GAChC,OAAQhD,EAAG+C,IAAY/C,EAAG+C,IAAWA,GAAUC,G,YA0BhD,MAAM,UAAgC,EAEzC,YAAYC,GACRL,QAFJ,mBAGI,EAAA7B,KAAI,EAAakC,GAGf,QAAQC,G,yCACV,IAAIC,EAA4B,GAC5BxB,EAAQ,KACRqB,EAAW,KACf,IAAK,IAAIrC,KAAMuC,EAAKtB,OAChBD,EAAQuB,EAAKtB,OAAOjB,GACpBqC,EAAWrB,EAAMyB,OAAS3C,EAAqBkB,EAAMyB,QAAU,KAC3DrC,KAAKsC,UAAUH,EAAKvC,GAAIqC,IACxBG,EAASlC,KAAK,EAAAF,KAAA,GAAeuC,QAAQ3B,EAAMf,SAAUe,EAAMjB,IAAKwC,EAAKrC,OAG7E,aADM0C,QAAQC,IAAIL,IACX,M,gjBCxCR,MAAM,EACT,cAAcM,GACV,IAAIlC,EAAY,IAAI,EAAwB,IAAI,GAC5CmC,EAAM,IAAI,EAAY,IAAIf,EAAuBpB,GAAYkC,aAAK,EAALA,EAAOlF,MAIxE,OAHIyB,EAAGyD,aAAK,EAALA,EAAOjC,SACVkC,EAAIC,UAAUF,EAAMjC,QAEjBkC,GAIR,MAAM,EAMT,YAAYE,EAAmCrF,GAL/C,mBACA,mBACA,mBACA,mBACA,mBAEI,EAAAwC,KAAI,EAAW,IACf,EAAAA,KAAI,EAAiB6C,GACrB,EAAA7C,KAAI,EAAYR,KAChB,EAAAQ,KAAI,EAASxC,UAAQ,aAGzB,UAAUiD,GACN,EAAAT,KAAI,EAAWS,GAUnB,GAAGjD,EAAcqC,EAAeF,EAAsB0C,INCnD,YAAgBS,GACnB,IAAK7D,EAAG6D,GACJ,OAAO,EAEX,IAAIxF,EAAIwF,EAAW1D,OACnB,IAAK,IAAInC,EAAI,EAAGA,EAAIK,EAAGL,IACnB,IAAKgC,EAAG6D,EAAW7F,IACf,OAAO,EAGf,OAAO,GMVE8F,CAAIvF,EAAMqC,IACXG,KAAKc,SAAS,KAAM,oBAGxB,IAAIlB,EAAKI,KAAKgD,eAAetD,EAAqBC,IAQlD,OANAK,KAAKiD,QAAQ,KAAM,yBAAyBzF,YAAeoC,MACtD,EAAAI,KAAA,GAAaxC,KACd,EAAAwC,KAAA,GAAaxC,GAAQ,IAGzB,EAAAwC,KAAA,GAAaxC,GAAMoC,GAAM,CAAED,IAAKA,EAAKE,SAAUA,EAAUwC,OAAQA,GAC1DzC,EASX,OAAOpC,EAAcmC,GACZV,EAAGzB,IACJwC,KAAKc,SAAS,SAAU,oBAE5B,IAAIoC,EAAK,EAAAlD,KAAA,GAAaxC,GAClBoC,EAAKF,EAAqBC,GAC9BK,KAAKiD,QAAQ,SAAU,oBAAoBrD,YAAapC,MACpDwC,KAAKmD,WAAWD,EAAItD,WACbsD,EAAGtD,GASlB,UAAUpC,GACFyB,EAAGzB,IAAS,EAAAwC,KAAA,GAAaxC,UAClB,EAAAwC,KAAA,GAAaxC,GAEpBwC,KAAKc,SAAS,YAAa,sCAW7B,KAAKF,EAAeyB,KAA4BvC,G,yCAC7Cb,EAAG2B,IACJZ,KAAKiD,QAAQ,OAAQ,2BAEzB,IAAIrD,EAAKF,EAAqB2C,GAG9B,OAFArC,KAAKiD,QAAQ,OAAQ,UAAUrC,YAAgBhB,YACzC,EAAAI,KAAA,GAAmBoD,OAAOxC,EAAO,EAAAZ,KAAA,GAAaY,GAAQhB,EAAIE,IACzD,KASX,cAActC,EAAcmC,GACxB,IAAIuD,EAAK,EAAAlD,KAAA,GAAaxC,GACtB,OAAOwC,KAAKmD,WAAWD,EAAIxD,EAAqBC,IAG5C,WAAWuD,EAAsBtD,GACrC,OAAOX,EAAGiE,IAAOjE,EAAGW,IAAOX,EAAGiE,EAAGtD,IAG7B,eAAeD,GACnB,OAAOV,EAAGU,GAAOA,EAAMK,KAAKqD,mBAGxB,SAAS1D,EAAa0B,GAC1BrB,KAAKwB,IFhIQ,QEgIG7B,EAAK0B,GAGjB,QAAQ1B,EAAa0B,GACzBrB,KAAKwB,IFnIO,OEmIG7B,EAAK0B,GAGhB,IAAId,EAAcZ,EAAa0B,GAC/B,EAAArB,KAAA,IACA,EAAAA,KAAA,QAAAA,KAAaO,EAAMZ,GAAK,IAAI+B,MAAOC,iBAAkBN,GAIrD,mBACJ,OAAO,EAAArB,KAAA,GAAa,IAAM,EAAAA,KAAA,GAAcyB,OAAOvD,O","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cui-light\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cui-light\"] = factory();\n\telse\n\t\troot[\"cui-light\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { ContextArgument } from \"./interfaces\";\r\n\r\n/**\r\n * Checks if value is defined an is not null\r\n * Additionally with type check it can check value if it is not empty string or collection or object\r\n * \r\n * @param val - value\r\n * @param typecheck - default true - additional check whether value is not empty (string, collection, object)\r\n * @returns whether value passed all conditions\r\n */\r\nexport function is(val: any, typecheck: boolean = true): boolean {\r\n    if (typeof val !== 'undefined' && val !== null) {\r\n        if (!typecheck) {\r\n            return true;\r\n        } else {\r\n            return !isEmpty(val)\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if value is empty string, array or object\r\n *\r\n *\r\n * @param val - value\r\n * @returns whether value passed all conditions\r\n */\r\nexport function isEmpty(val: any): boolean {\r\n    if (typeof val === \"string\") {\r\n        return val.length === 0\r\n    }\r\n    if (typeof val === \"boolean\") {\r\n        return val;\r\n    }\r\n    else if (Array.isArray(val)) {\r\n        return val.length === 0\r\n    }\r\n    return false\r\n}\r\n\r\n/**\r\n * Verifies whether attributes exist and have some values\r\n * @param attributes attributes list\r\n */\r\nexport function are(...attributes: any[]): boolean {\r\n    if (!is(attributes)) {\r\n        return false\r\n    }\r\n    let c = attributes.length;\r\n    for (let i = 0; i < c; i++) {\r\n        if (!is(attributes[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nexport function* counter() {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function getContextArgumentId(ctx: ContextArgument): string {\r\n    if (!ctx) {\r\n        return null;\r\n    } else if (typeof ctx === 'string') {\r\n        return ctx;\r\n    } else {\r\n        return ctx.id;\r\n    }\r\n}","import { is } from \"./functions\"\r\nimport { IBpdCallbackExecutor } from \"./interfaces\"\r\n\r\n\r\nexport class BpdCallbackExecutor implements IBpdCallbackExecutor {\r\n    async execute(callback: any, ctx: any, args: any[]): Promise<void> {\r\n        args = args ?? []\r\n        if (is(ctx)) {\r\n            callback.apply(ctx, args)\r\n        } else {\r\n            callback(...args)\r\n        }\r\n        return\r\n    }\r\n}","import { IBpdCollection, BpdCollectionPair } from \"./interfaces\";\r\nimport { is } from \"./functions\";\r\n\r\nexport class BpdEventsCollection<T> implements IBpdCollection<T> {\r\n    #keys: string[];\r\n    #values: T[];\r\n    constructor() {\r\n        this.#keys = []\r\n        this.#values = []\r\n    }\r\n\r\n\r\n    add(key: string, value: T): void {\r\n        if (is(key) && !this.has(key)) {\r\n            this.#keys.push(key);\r\n            this.#values.push(value);\r\n        }\r\n    }\r\n\r\n    remove(key: string): void {\r\n        if (is(key) && this.has(key)) {\r\n            let index = this.indexOf(key);\r\n            if (index > -1) {\r\n                this.#keys.splice(index, 1);\r\n                this.#values.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    has(key: string): boolean {\r\n        return this.#keys.includes(key);\r\n    }\r\n\r\n    get(index: number): BpdCollectionPair<T> {\r\n        if (index > -1 && index < this.length()) {\r\n            return {\r\n                key: this.#keys[index],\r\n                value: this.#values[index]\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    first(): BpdCollectionPair<T> {\r\n        return this.get(0);\r\n    }\r\n\r\n    length(): number {\r\n        return this.#keys.length;\r\n    }\r\n\r\n    indexOf(key: string): number {\r\n        return this.#keys.indexOf(key);\r\n    }\r\n\r\n}","import { BpdEventReceiver, IBpdEventEmitHandler, IBpdCallbackExecutor, BpdEventLogger, IBpdCollection, IBpdHandlerPerformer, EmitHandlerData } from \"./interfaces\";\r\nimport { is, getContextArgumentId, counter } from \"./functions\";\r\nimport { INFO, ERROR } from \"./statics\";\r\nimport { BpdEventsCollection } from \"./collection\";\r\n\r\n\r\n\r\nabstract class EmitHandlerBase {\r\n    isBusy: boolean;\r\n    queue: IBpdCollection<EmitHandlerData>;\r\n    #logger: BpdEventLogger;\r\n    #type: string;\r\n    #counter: Generator<number, void, unknown>;\r\n    #performer: IBpdHandlerPerformer;\r\n    constructor(type: string, performer: IBpdHandlerPerformer, logger?: BpdEventLogger) {\r\n        this.queue = new BpdEventsCollection();\r\n        this.#performer = performer;\r\n        this.isBusy = false;\r\n        this.#logger = logger;\r\n        this.#type = type;\r\n        this.#counter = counter();\r\n    }\r\n\r\n    async handle(event: string, events: BpdEventReceiver, id: string, args: any[]): Promise<boolean> {\r\n        if (!is(events)) {\r\n            this.logError(\"handle\", \"No events provided\")\r\n            return\r\n        }\r\n        let key = this.createKey(event, args);\r\n        this.queue.add(key, {\r\n            events: events,\r\n            id: id,\r\n            args: args\r\n        })\r\n\r\n        if (!this.isBusy) {\r\n            this.isBusy = true;\r\n            let queueItem = null;\r\n            while (this.queue.length() > 0) {\r\n                queueItem = this.queue.first();\r\n                try {\r\n                    await this.#performer.perform(queueItem.value);\r\n                } catch (e) {\r\n                    this.logError(\"perform\", e.message)\r\n                } finally {\r\n                    this.queue.remove(queueItem.key);\r\n                }\r\n\r\n            }\r\n            this.isBusy = false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    protected logEvent(context: string, message?: string) {\r\n        this.log(INFO, context, message)\r\n    }\r\n\r\n    protected logError(context: string, message?: string) {\r\n        this.log(ERROR, context, message)\r\n    }\r\n\r\n    protected nextId(): string {\r\n        return \"#\" + this.#counter.next().value;\r\n    }\r\n\r\n    private log(type: string, context: string, message?: string) {\r\n        if (is(this.#logger)) {\r\n            this.#logger(type, `[${this.#type}]-[${context}]`, new Date().toLocaleString(), message)\r\n        }\r\n    }\r\n\r\n    protected abstract createKey(event: string, args: any[]): string;\r\n\r\n}\r\n\r\nexport class SimpleEventEmitHandler extends EmitHandlerBase implements IBpdEventEmitHandler {\r\n\r\n    constructor(performer: IBpdHandlerPerformer) {\r\n        super(\"SimpleEventEmitHandler\", performer);\r\n    }\r\n\r\n    createKey(eventName: string, args: any[]): string {\r\n        return this.nextId();\r\n    }\r\n}\r\n\r\n// Extended handler\r\n\r\nexport class ExtendedTaskedEventEmitHandler extends EmitHandlerBase implements IBpdEventEmitHandler {\r\n    constructor(performer: IBpdHandlerPerformer, logger?: BpdEventLogger) {\r\n        super(\"ExtendedTaskedEventEmitHandler\", performer), logger;\r\n    }\r\n\r\n    createKey(eventName: string, args: any[]): string {\r\n        let count = is(args) ? args.length : 0;\r\n        let id = null;\r\n        if (count > 0) {\r\n            if (args.length === 1) {\r\n                let val = args[0];\r\n                if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {\r\n                    id = \"s:\" + val;\r\n                } else if (val.id) {\r\n                    id = \"ID:\" + val.id;\r\n                } else if (val.key) {\r\n                    id = \"KEY:\" + val.key;\r\n                }\r\n            } else {\r\n\r\n            }\r\n            return [eventName, count, id === null ? JSON.stringify(args) : id].join(\"-\");\r\n        }\r\n\r\n        return [eventName, count].join(\"-\");\r\n    }\r\n}\r\n\r\n","export const ERROR = \"ERROR\";\r\nexport const INFO = \"INFO\";","import { is, getContextArgumentId } from \"./functions\";\r\nimport { IBpdHandlerPerformer, IBpdCallbackExecutor, EmitHandlerData } from \"./interfaces\";\r\n\r\nexport class BpdHandlePerformerBase {\r\n    protected idMatches(emitId: string, handleId: string) {\r\n        return !is(emitId) || (is(emitId) && emitId == handleId);\r\n    }\r\n}\r\n\r\nexport class BpdSimpleHandlePerformer extends BpdHandlePerformerBase implements IBpdHandlerPerformer {\r\n    #executor: IBpdCallbackExecutor;\r\n    constructor(executor: IBpdCallbackExecutor) {\r\n        super();\r\n        this.#executor = executor;\r\n    }\r\n\r\n    async perform(data: EmitHandlerData): Promise<boolean> {\r\n        let event = null;\r\n        let handleId = null;\r\n        for (let id in data.events) {\r\n            event = data.events[id]\r\n            handleId = event.target ? getContextArgumentId(event.target) : null;\r\n            if (this.idMatches(data.id, handleId))\r\n                await this.#executor.execute(event.callback, event.ctx, data.args)\r\n\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\nexport class BpdAsyncHandlePerformer extends BpdHandlePerformerBase implements IBpdHandlerPerformer {\r\n    #executor: IBpdCallbackExecutor;\r\n    constructor(executor: IBpdCallbackExecutor) {\r\n        super();\r\n        this.#executor = executor;\r\n    }\r\n\r\n    async perform(data: EmitHandlerData): Promise<boolean> {\r\n        let promises: Promise<void>[] = []\r\n        let event = null;\r\n        let handleId = null;\r\n        for (let id in data.events) {\r\n            event = data.events[id]\r\n            handleId = event.target ? getContextArgumentId(event.target) : null;\r\n            if (this.idMatches(data.id, handleId))\r\n                promises.push(this.#executor.execute(event.callback, event.ctx, data.args))\r\n        }\r\n        await Promise.all(promises)\r\n        return true;\r\n    }\r\n}","import { are, is, counter, getContextArgumentId } from \"./functions\";\r\nimport { IBpdEventBus, BpdEventReceiver, IBpdEventEmitHandler, BpdEventLogger, ContextArgument, BpdEventBusSetup } from \"./interfaces\";\r\nimport { BpdCallbackExecutor } from \"./executors\";\r\nimport { ERROR, INFO } from \"./statics\";\r\nimport { SimpleEventEmitHandler } from \"./handlers\";\r\nimport { BpdAsyncHandlePerformer } from \"./performers\";\r\n\r\nexport { BpdEventContext as CuiEventContext } from \"./interfaces\";\r\n\r\nexport class BpdEventBusFactory {\r\n    static create(setup?: BpdEventBusSetup): IBpdEventBus {\r\n        let performer = new BpdAsyncHandlePerformer(new BpdCallbackExecutor())\r\n        let bus = new BpdEventBus(new SimpleEventEmitHandler(performer), setup?.name);\r\n        if (is(setup?.logger)) {\r\n            bus.setLogger(setup.logger);\r\n        }\r\n        return bus;\r\n    }\r\n}\r\n\r\nexport class BpdEventBus implements IBpdEventBus {\r\n    #events: { [event: string]: BpdEventReceiver }\r\n    #eventHandler: IBpdEventEmitHandler;\r\n    #logger: BpdEventLogger;\r\n    #counter: Generator<number, void, unknown>;\r\n    #name: string;\r\n    constructor(emitHandler: IBpdEventEmitHandler, name?: string) {\r\n        this.#events = {};\r\n        this.#eventHandler = emitHandler;\r\n        this.#counter = counter();\r\n        this.#name = name ?? \"EVENT_BUS\";\r\n    }\r\n\r\n    setLogger(logger: BpdEventLogger) {\r\n        this.#logger = logger;\r\n    }\r\n    /**\r\n     * Attaches event to event bus\r\n     * \r\n     * @param {string} name - Event name\r\n     * @param {any} callback - callback function\r\n     * @param {ContextArgument} ctx - callback context with id\r\n     * @param {ContextArgument} target - optional - cui element which event shall be attached to\r\n     */\r\n    on(name: string, callback: any, ctx: ContextArgument, target?: ContextArgument): string {\r\n        if (!are(name, callback)) {\r\n            this.logError('on', \"Missing argument\")\r\n        }\r\n        // When context is not provided (e.g. anonymous function) then generate random\r\n        let id = this.prepareEventId(getContextArgumentId(ctx));\r\n\r\n        this.logInfo(\"on\", `Attaching new event: [${name}] for: [${id}]`)\r\n        if (!this.#events[name]) {\r\n            this.#events[name] = {}\r\n        }\r\n\r\n        this.#events[name][id] = { ctx: ctx, callback: callback, target: target }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n    * Detaches specific event from event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    detach(name: string, ctx: ContextArgument): void {\r\n        if (!is(name)) {\r\n            this.logError(\"detach\", \"Missing argument\")\r\n        }\r\n        let ev = this.#events[name]\r\n        let id = getContextArgumentId(ctx);\r\n        this.logInfo(\"detach\", `Detaching item: [${id}] from [${name}]`);\r\n        if (this.isAttached(ev, id)) {\r\n            delete ev[id];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Detaches all callbacks from event\r\n    *\r\n    * @param {string} name - Event name\r\n    */\r\n    detachAll(name: string): void {\r\n        if (is(name) && this.#events[name]) {\r\n            delete this.#events[name]\r\n        } else {\r\n            this.logError(\"detachAll\", \"Event name is missing or incorrect\")\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Emits event call to event bus\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} cuid - id of component which emits the event\r\n    * @param {any[]} args  - event arguments\r\n    */\r\n    async emit(event: string, target: ContextArgument, ...args: any[]): Promise<boolean> {\r\n        if (!is(event)) {\r\n            this.logInfo(\"emit\", \"Event name is incorrect\")\r\n        }\r\n        let id = getContextArgumentId(target);\r\n        this.logInfo(\"emit\", `Emit: [${event}], id: [${id}]`);\r\n        await this.#eventHandler.handle(event, this.#events[event], id, args)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Checks whether given context is already attached to specific event\r\n    *\r\n    * @param {string} name - Event name\r\n    * @param {ContextArgument} ctx - callback context with id\r\n    */\r\n    isSubscribing(name: string, ctx: ContextArgument) {\r\n        let ev = this.#events[name]\r\n        return this.isAttached(ev, getContextArgumentId(ctx))\r\n    }\r\n\r\n    private isAttached(ev: BpdEventReceiver, id: string): boolean {\r\n        return is(ev) && is(id) && is(ev[id]);\r\n    }\r\n\r\n    private prepareEventId(ctx: string) {\r\n        return is(ctx) ? ctx : this.getRandomEventId();\r\n    }\r\n\r\n    private logError(ctx: string, message?: string) {\r\n        this.log(ERROR, ctx, message);\r\n    }\r\n\r\n    private logInfo(ctx: string, message?: string) {\r\n        this.log(INFO, ctx, message);\r\n    }\r\n\r\n    private log(type: string, ctx: string, message?: string) {\r\n        if (this.#logger) {\r\n            this.#logger(type, ctx, new Date().toLocaleString(), message);\r\n        }\r\n    }\r\n\r\n    private getRandomEventId(): string {\r\n        return this.#name + \"_\" + this.#counter.next().value;\r\n    }\r\n}   "],"sourceRoot":""}